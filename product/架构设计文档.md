# 架构设计文档

## 1. 架构概述

本项目采用现代化的前端架构设计，基于React 18 + TypeScript + Vite构建，遵循组件化、模块化和可维护性原则。项目采用分层架构，清晰分离关注点，提高代码复用性和可扩展性。

## 2. 架构分层

### 2.1 组件层（Components Layer）

组件层是应用的UI表现层，负责用户界面的渲染和用户交互。组件按功能模块进行划分，保持高内聚低耦合的设计原则。

#### 2.1.1 组件分类

- **页面组件**：位于`src/pages`目录，代表完整的页面，如Home组件
- **业务组件**：位于`src/components`目录，实现特定业务功能的组件
- **基础组件**：可复用的UI组件（当前项目未单独划分，可根据需求扩展）

#### 2.1.2 组件设计原则

- **单一职责**：每个组件只负责一个明确的功能
- **可复用性**：设计通用组件，提高代码复用率
- **可测试性**：组件逻辑清晰，易于单元测试
- **类型安全**：使用TypeScript定义组件Props和State类型

### 2.2 上下文层（Context Layer）

上下文层使用React Context API实现全局状态管理，避免了props drilling问题，提供了高效的状态共享机制。

#### 2.2.1 核心上下文

- **AuthContext**：管理用户认证状态
- **ThemeContext**：管理主题设置（明亮/暗黑模式）
- **BookmarkContext**：管理书签数据和隐藏分类设置
- **EnterpriseLinkContext**：管理企业链接数据和锁定状态

#### 2.2.2 上下文设计原则

- **最小化状态**：只将需要全局共享的状态放入Context
- **避免过度使用**：对于局部状态，优先使用组件内部状态管理
- **提供Provider HOC**：为Context提供便捷的Provider包装组件
- **类型安全**：定义清晰的Context类型接口

### 2.3 钩子层（Hooks Layer）

钩子层封装了业务逻辑和副作用处理，提供了可复用的逻辑单元，使组件代码更加简洁和专注于UI渲染。

#### 2.3.1 核心钩子

- **useTheme**：封装主题切换和管理逻辑
- **useEnterpriseLinks**：封装企业链接管理逻辑
- **useDateTime**：封装日期时间处理和事件提醒逻辑
- **useSearch**：封装搜索功能和搜索引擎切换逻辑

#### 2.3.2 钩子设计原则

- **单一职责**：每个钩子只处理一个特定的功能领域
- **可组合性**：钩子可以组合使用，实现复杂功能
- **副作用隔离**：将副作用（如API调用、localStorage操作）封装在钩子内部
- **类型安全**：定义清晰的输入输出类型

### 2.4 数据层（Data Layer）

数据层负责数据的获取、存储和管理，包括模拟数据、API调用和本地存储。

#### 2.4.1 数据来源

- **模拟数据**：位于`src/data/index.ts`，提供初始演示数据
- **本地存储**：使用localStorage进行数据持久化
- **API调用**：预留API集成接口，可根据需求扩展

#### 2.4.2 数据管理原则

- **数据中心化**：集中管理应用数据，避免数据分散
- **状态一致性**：确保数据在不同组件间的一致性
- **持久化策略**：关键数据进行本地存储，避免页面刷新数据丢失

### 2.5 工具层（Utility Layer）

工具层提供通用的工具函数和辅助方法，支持各层的功能实现。

#### 2.5.1 核心工具

- **src/lib/utils.ts**：通用工具函数集合
- **类型定义**：位于`src/types`目录，定义应用的数据结构
- **枚举定义**：位于`src/enum`目录，定义应用的枚举类型

#### 2.5.2 工具设计原则

- **通用性**：工具函数应具有广泛的适用性
- **无副作用**：纯函数设计，避免修改外部状态
- **可测试性**：工具函数易于单元测试

## 3. 数据流设计

### 3.1 单向数据流

应用采用单向数据流模式，确保数据流动的可预测性：

1. 用户交互触发组件事件
2. 组件调用Context的更新函数或自定义Hook
3. Context或Hook更新状态并触发重新渲染
4. 状态变化通过Context或props传递给相关组件
5. 组件根据新状态重新渲染UI

### 3.2 数据持久化

应用使用localStorage实现数据持久化，主要存储以下数据：

- 主题设置
- 书签数据
- 快捷链接配置
- 隐藏分类设置
- 背景图片设置

### 3.3 数据初始化流程

1. 应用启动时，从localStorage加载保存的数据
2. 如果localStorage中没有数据，则使用默认值或模拟数据
3. 初始化完成后，数据通过Context提供给所有组件

## 4. 核心模块设计

### 4.1 主题管理模块

**功能**：实现明亮/暗黑模式切换和管理

**架构设计**：

- 使用`ThemeContext`提供全局主题状态
- `useTheme` Hook封装主题切换逻辑
- 监听系统主题偏好设置，自动适配
- 支持跨标签页主题同步

**关键代码**：

```typescript
// ThemeContext.tsx
export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    const savedTheme = localStorage.getItem('theme') as Theme;
    if (savedTheme) return savedTheme;
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  });

  // 主题切换逻辑
  const toggleTheme = useCallback(() => {
    setTheme(prevTheme => {
      const newTheme = prevTheme === 'light' ? 'dark' : 'light';
      document.documentElement.classList.remove('light', 'dark');
      document.documentElement.classList.add(newTheme);
      localStorage.setItem('theme', newTheme);
      return newTheme;
    });
  }, []);

  // 提供主题上下文
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, isDark: theme === 'dark' }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

### 4.2 书签管理模块

**功能**：分类管理个人书签，支持隐藏/显示分类

**架构设计**：

- 使用`BookmarkContext`提供书签数据和操作方法
- `BookmarksGrid`组件负责书签的展示
- `BookmarkManagementModal`组件负责书签的管理
- 支持按分类隐藏/显示书签

**关键代码**：

```typescript
// BookmarkContext.tsx
export const BookmarkProvider: React.FC<BookmarkProviderProps> = ({ children }) => {
  const [bookmarks, setBookmarks] = useState<BookmarkCategory[]>([]);
  const [hiddenCategories, setHiddenCategories] = useState<BookmarkVisibilitySettings>({});

  // 隐藏分类逻辑
  const hideCategory = (tabId: string, category: string) => {
    setHiddenCategories(prev => {
      const currentHidden = prev[tabId] || [];
      if (!currentHidden.includes(category)) {
        return {
          ...prev,
          [tabId]: [...currentHidden, category]
        };
      }
      return prev;
    });
  };

  // 提供书签上下文
  return (
    <BookmarkContext.Provider value={{ 
      bookmarks, 
      hiddenCategories, 
      hideCategory,
      showCategory,
      isCategoryHidden 
    }}>
      {children}
    </BookmarkContext.Provider>
  );
};
```

## 5. 性能优化策略

### 5.1 组件优化

- **React.memo**：对于纯展示组件使用React.memo减少不必要的渲染
- **useMemo/useCallback**：缓存计算结果和函数引用，避免不必要的重新计算
- **懒加载**：使用React.lazy和Suspense实现组件懒加载（当前项目未实现，可根据需求扩展）

### 5.2 资源优化

- **图片优化**：背景图片使用适当压缩，支持WebP格式（当前项目未实现，可根据需求扩展）
- **代码分割**：使用动态导入实现代码分割，减少首屏加载时间（当前项目未实现，可根据需求扩展）
- **CSS优化**：使用Tailwind CSS的JIT模式，减少CSS文件大小

### 5.3 渲染优化

- **虚拟滚动**：对于大量数据列表，使用虚拟滚动减少DOM节点数量（当前项目未实现，可根据需求扩展）
- **避免不必要的重渲染**：合理使用shouldComponentUpdate或React.memo
- **状态管理优化**：最小化状态更新范围，避免全局重渲染

## 6. 代码组织规范

### 6.1 目录结构

```
src/
├── components/          # 组件目录
│   ├── ComponentA.tsx   # 组件实现
│   └── ComponentB.tsx
├── contexts/            # Context目录
│   ├── contextA.tsx    # Context实现
│   └── contextB.tsx
├── hooks/              # Hooks目录
│   ├── useHookA.ts     # Hook实现
│   └── useHookB.ts
├── pages/              # 页面目录
│   ├── PageA.tsx       # 页面组件
│   └── PageB.tsx
├── types/              # 类型定义目录
│   └── index.ts        # 集中定义类型
├── enum/               # 枚举定义目录
│   └── index.ts        # 集中定义枚举
├── data/               # 数据目录
│   └── index.ts        # 模拟数据
├── lib/                # 工具目录
│   └── utils.ts        # 工具函数
├── App.tsx             # 应用入口组件
├── index.css           # 全局样式
└── main.tsx            # 应用主入口
```

### 6.2 命名规范

- **组件命名**：PascalCase，如`Sidebar.tsx`
- **Hook命名**：以`use`开头，camelCase，如`useTheme.ts`
- **类型命名**：PascalCase，如`ThemeContextType`
- **枚举命名**：PascalCase，如`SearchEngine`
- **变量/函数命名**：camelCase，如`toggleTheme`

### 6.3 编码规范

- **TypeScript**：严格使用类型定义，避免any类型
- **注释**：使用JSDoc格式注释组件、函数和类型
- **代码风格**：遵循ESLint和Prettier配置
- **组件结构**：
  1. 导入语句
  2. 类型定义
  3. 组件实现
  4. 导出语句

## 7. 扩展性设计

### 7.1 功能扩展性

- **模块化设计**：功能模块独立，便于扩展和维护
- **预留接口**：关键功能预留扩展接口，如AI书签分类、云同步等
- **插件系统**：可考虑设计插件系统，支持第三方功能扩展（当前项目未实现，可根据需求扩展）

### 7.2 技术扩展性

- **API集成**：预留API集成接口，可从模拟数据切换到真实API
- **状态管理扩展**：当前使用Context API，可根据需求切换到Redux Toolkit或Zustand
- **UI库扩展**：当前使用Tailwind CSS，可集成其他UI组件库

### 7.3 性能扩展性

- **缓存策略**：预留缓存策略扩展接口
- **CDN集成**：支持静态资源CDN加速
- **服务端渲染**：可考虑扩展到Next.js实现SSR或SSG

## 8. 测试策略

### 8.1 测试分层

- **单元测试**：测试组件、Hook和工具函数的独立功能
- **集成测试**：测试组件间的交互和数据流
- **E2E测试**：测试完整的用户流程（当前项目未实现，可根据需求扩展）

### 8.2 测试工具

- **Jest**：单元测试框架
- **React Testing Library**：组件测试库
- **Playwright**：E2E测试工具（可选）

### 8.3 测试覆盖率目标

- 组件测试覆盖率：≥80%
- Hook测试覆盖率：≥90%
- 工具函数测试覆盖率：≥95%

## 9. 部署与CI/CD

### 9.1 构建流程

1. 安装依赖：`pnpm install`
2. 类型检查：`pnpm run typecheck`
3. 代码检查：`pnpm run lint`
4. 单元测试：`pnpm run test`
5. 构建生产版本：`pnpm run build`

### 9.2 部署策略

- **静态部署**：构建产物为静态文件，可部署到任何静态文件服务器
- **容器化部署**：可使用Docker容器化部署（当前项目未实现，可根据需求扩展）
- **CI/CD集成**：可集成GitHub Actions、GitLab CI等实现自动构建和部署

## 10. 架构演进规划

### 10.1 短期规划（0-3个月）

- 完善单元测试和集成测试
- 实现API集成，替换模拟数据
- 优化性能和用户体验

### 10.2 中期规划（3-6个月）

- 实现云同步功能
- 集成用户认证系统
- 开发移动端适配

### 10.3 长期规划（6-12个月）

- 支持多用户协作功能
- 实现AI智能助手功能
- 扩展到企业级应用场景

---

**文档版本**：v1.0.0  
**最后更新**：2024年12月  
**作者**：开发团队